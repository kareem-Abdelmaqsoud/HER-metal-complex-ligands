from rdkit import Chem
from rdkit.Chem import rdMolDescriptors, MACCSkeys
from rdkit.Chem import Descriptors, Lipinski, Crippen, rdMolDescriptors
from rdkit import DataStructs
import numpy as np
import pandas as pd

def generate_fingerprints(mol):
    """Generate various fingerprints for a molecule"""
    results = {}
    
    # Morgan fingerprint (radius=2, 2048 bits)
    morgan_fp = rdMolDescriptors.GetMorganFingerprintAsBitVect(mol, radius=2, nBits=2048)
    results['Morgan'] = np.array(morgan_fp)
    
    # MACCS keys (166 bits)
    maccs_fp = MACCSkeys.GenMACCSKeys(mol)
    results['MACCS'] = np.array(maccs_fp)
    
    # Topological fingerprint (2048 bits)
    topo_fp = Chem.RDKFingerprint(mol, fpSize=2048)
    results['Topological'] = np.array(topo_fp)
    
    # Atom pair fingerprint (2048 bits)
    atompair_fp = rdMolDescriptors.GetHashedAtomPairFingerprintAsBitVect(mol, nBits=2048)
    results['AtomPair'] = np.array(atompair_fp)

    return results

def print_fp_stats(results, mol_name):
    print(f"{mol_name} Fingerprint Analysis:")
    print("=" * 35)
    for fp_type, fp_array in results.items():
        bits_on = np.sum(fp_array)
        total_bits = len(fp_array)
        density = bits_on / total_bits * 100
        print(f"{fp_type:12}: {bits_on:3d}/{total_bits} bits on ({density:.1f}% density)")
    print()

def calculate_similarity_matrix(molecules_dict, fp_type='Morgan', similarity_metric='Tanimoto'):
    """Calculate pairwise similarities between molecules"""
    mol_names = list(molecules_dict.keys())
    n_mols = len(mol_names)
    
    # Generate fingerprints using the generate_fingerprints function
    fingerprints = {}
    for name, smiles in molecules_dict.items():
        mol = Chem.MolFromSmiles(smiles)
        # Use generate_fingerprints to get all types, then select the desired one
        all_fps = generate_fingerprints(mol) 
        if fp_type in all_fps:
            # Convert numpy array back to ExplicitBitVect for similarity calculations
            bit_vector = DataStructs.CreateFromBitString(''.join(all_fps[fp_type].astype(str)))
            fingerprints[name] = bit_vector
        else:
            raise ValueError(f"Fingerprint type '{fp_type}' not generated by generate_fingerprints.")
    
    # Calculate pairwise similarities
    similarity_matrix = np.zeros((n_mols, n_mols))
    
    for i, name1 in enumerate(mol_names):
        for j, name2 in enumerate(mol_names):
            if i == j:
                similarity_matrix[i][j] = 1.0
            else:
                if similarity_metric == 'Tanimoto':
                    sim = DataStructs.TanimotoSimilarity(fingerprints[name1], fingerprints[name2])
                elif similarity_metric == 'Dice':
                    sim = DataStructs.DiceSimilarity(fingerprints[name1], fingerprints[name2])
                else:
                    raise ValueError(f"Unsupported similarity metric: {similarity_metric}")
                similarity_matrix[i][j] = sim
    
    return similarity_matrix


def visualize_similarity(sim_matrix, names, cmap, fp_name, sim_name):
    """Visualize similarity matrix as heatmap"""
    import matplotlib.pyplot as plt
    import seaborn as sns

    fig, ax = plt.subplots(figsize=(16, 12))

    # Create heatmap
    sns.heatmap(sim_matrix, 
                xticklabels=names, 
                yticklabels=names,
                annot=False, 
                fmt='.2f', 
                cmap=cmap,
                square=True,
                cbar_kws={'label': f'{sim_name} Similarity'},
                ax=ax)

    ax.set_title(f'Molecular Similarity Heatmap\n({fp_name} Fingerprints)', 
                fontsize=16, fontweight='bold', pad=20)
    ax.set_xlabel('Molecules', fontsize=12)
    ax.set_ylabel('Molecules', fontsize=12)

    plt.tight_layout()
    plt.show()

    # Find most similar pair
    max_sim = 0
    most_similar = None
    for i in range(len(names)):
        for j in range(i+1, len(names)):
            if sim_matrix[i][j] > max_sim:
                max_sim = sim_matrix[i][j]
                most_similar = (names[i], names[j])

    print(f"\nMost similar pair: {most_similar[0]} & {most_similar[1]} (Similarity: {max_sim:.3f})")


def visualize_similarity_interactive(sim_matrix, names, cmap, fp_name, sim_name):
    """Visualize similarity matrix as heatmap using Plotly"""
    import plotly.express as px
    import numpy as np

    colorscale = cmap 

    # Create heatmap with Plotly
    fig = px.imshow(sim_matrix,
                    x=names,
                    y=names,
                    color_continuous_scale=colorscale,
                    labels=dict(x="Molecules", y="Molecules", color=f"{sim_name} Similarity"),
                    title=f"Molecular Similarity Heatmap ({fp_name} Fingerprints)",
                    aspect="equal")  

    fig.update_layout(
        width=1000,
        height=1000,
        title_font_size=20,
        xaxis_title_font_size=14,
        yaxis_title_font_size=14,
        coloraxis_colorbar_title_font_size=12
    )

    if len(names) > 50:
        fig.update_xaxes(showticklabels=False)
        fig.update_yaxes(showticklabels=False)
    elif len(names) > 20:
        fig.update_xaxes(tickangle=45, tickfont_size=10)
        fig.update_yaxes(tickfont_size=10)

    fig.show()

    # Find most similar pair
    max_sim = 0
    most_similar = None
    for i in range(len(names)):
        for j in range(i+1, len(names)):
            if sim_matrix[i][j] > max_sim:
                max_sim = sim_matrix[i][j]
                most_similar = (names[i], names[j])

    print(f"\nMost similar pair: {most_similar[0]} & {most_similar[1]} (Similarity: {max_sim:.3f})")


def calculate_descriptors(mol, mol_name):
    """Calculate important molecular descriptors"""
    descriptors = {
        'Name': mol_name,
        
        # Constitutional descriptors
        'MW': Descriptors.MolWt(mol),
        'HeavyAtoms': mol.GetNumHeavyAtoms(),
        'NumBonds': mol.GetNumBonds(),
        'NumRings': Descriptors.RingCount(mol),
        'NumAromaticRings': Descriptors.NumAromaticRings(mol),
        
        # Lipinski descriptors (drug-likeness)
        'LogP': Crippen.MolLogP(mol),
        'HBD': Lipinski.NumHDonors(mol),  # H-bond donors
        'HBA': Lipinski.NumHAcceptors(mol),  # H-bond acceptors
        'TPSA': rdMolDescriptors.CalcTPSA(mol),  # Topological polar surface area
        
        # Topological descriptors
        'BertzCT': Descriptors.BertzCT(mol),  # Complexity
        'Chi0v': Descriptors.Chi0v(mol),  # Connectivity index
        'Kappa1': Descriptors.Kappa1(mol),  # Shape index
        
        # Electronic descriptors  
        'NumRotatableBonds': rdMolDescriptors.CalcNumRotatableBonds(mol),
        # 'FractionCsp3': rdMolDescriptors.CalcFractionCsp3(mol)
        'FractionCsp3': rdMolDescriptors.CalcFractionCSP3(mol)
    }
    
    return descriptors

# def calculate_descriptors(mol, mol_name):
#     """
#     Calculate a comprehensive set of molecular descriptors using RDKit's CalcMolDescriptors.
#     """
    
#     # Get all standard RDKit descriptors
#     all_rdkit_descriptors = Descriptors.CalcMolDescriptors(mol)
    
#     # Add the molecule name to the dictionary
#     all_rdkit_descriptors['Name'] = mol_name
    
#     return all_rdkit_descriptors
    
def analyze_substructures(molecules_dict, patterns_dict):
    """Analyze substructure patterns in molecules"""
    results = []
    
    for mol_name, smiles in molecules_dict.items():
        mol = Chem.MolFromSmiles(smiles)
        row = {'Molecule': mol_name}
        
        for pattern_name, smarts in patterns_dict.items():
            pattern = Chem.MolFromSmarts(smarts)
            if pattern:
                matches = mol.GetSubstructMatches(pattern)
                row[pattern_name] = len(matches)
            else:
                row[pattern_name] = 0
                
        results.append(row)
    
    return pd.DataFrame(results)

if __name__ == "__main__":
    print("Available Descriptors from rdkit.Chem.Descriptors:")
    print("=" * 50)
    for desc_name in dir(Descriptors):
        if not desc_name.startswith('_') and callable(getattr(Descriptors, desc_name)):
            print(f"- {desc_name}")
    print("\nAvailable Descriptors from rdkit.Chem.rdMolDescriptors (some might overlap):")
    print("=" * 70)
    for desc_name in dir(rdMolDescriptors):
        if not desc_name.startswith('_') and callable(getattr(rdMolDescriptors, desc_name)):
            print(f"- {desc_name}")